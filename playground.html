<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>

<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/rollups/aes.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/rollups/pbkdf2.js"></script>
<body>
<script>
    const ALGORITHM_NAME = "AES-GCM";
    const ALGORITHM_NONCE_SIZE = 12;
    const ALGORITHM_KEY_SIZE = 256;
    const PBKDF2_SALT_SIZE = 16;
    const PBKDF2_ITERATIONS = 32767;

    function bufferToBase64(buf) {
        var binstr = Array.prototype.map.call(buf, function (ch) {
            return String.fromCharCode(ch);
        }).join('');
        return btoa(binstr);
    }

    function joinBuffers(a, b) {
        let c = new Uint8Array(a.byteLength + b.byteLength);

        for (let i = 0; i < a.length; i++) {
            c[i] = a[i];
        }
        for (let i = 0; i < b.length; i++) {
            c[i + a.length] = b[i];
        }

        return c;
    }

    async function encryptString(plaintext, password) {
        // Generate a 128-bit salt using a CSPRNG and a nonce.
        let salt = crypto.getRandomValues(new Uint8Array(PBKDF2_SALT_SIZE));
        let nonce = crypto.getRandomValues(new Uint8Array(ALGORITHM_NONCE_SIZE));
        let aesGcm = { name: ALGORITHM_NAME, iv: nonce };

        // Derive a key using PBKDF2.
        let deriveParams = { name: "PBKDF2", salt: salt, iterations: PBKDF2_ITERATIONS, hash: { name: "SHA-256" } };
        let rawKey = await crypto.subtle.importKey("raw", (new TextEncoder()).encode(password), { name: "PBKDF2" }, false, ["deriveKey", "deriveBits"]);
        let cryptoKey = await crypto.subtle.deriveKey(deriveParams, rawKey, { name: ALGORITHM_NAME, length: ALGORITHM_KEY_SIZE }, true, ["encrypt"]);

        // Encrypt the string.
        let ciphertext = await encryptWithCryptoKey(aesGcm, (new TextEncoder()).encode(plaintext), cryptoKey);
        return bufferToBase64(joinBuffers(salt, ciphertext));
    }

    async function encryptWithCryptoKey(aesGcm, plaintext, cryptoKey) {
        let ciphertext = await crypto.subtle.encrypt(aesGcm, cryptoKey, plaintext);
        return joinBuffers(aesGcm.iv, new Uint8Array(ciphertext));
    }

    (async function () {
        var message = 'My string - Could also be an JS array/object ';
        var iv = 'a1a2a3a4a5a6a7a8b1b2b3b4b5b6b7b8';
        var key = 'c1c2c3c4c5c6c7c8d1d2d3d4d5d6d7d8c1c2c3c4c5c6c7c8d1d2d3d4d5d6d7d8'; // 256-bit hex encoded

        var keyBytes = CryptoJS.enc.Hex.parse(key);
        var ivBytes = CryptoJS.enc.Hex.parse(iv);

        var encrypt = CryptoJS.AES.encrypt(message, keyBytes, {
            iv: ivBytes,
            padding: CryptoJS.pad.Pkcs7
        }).ciphertext.toString(CryptoJS.enc.Base64);

        var xhttp = new XMLHttpRequest();
        xhttp.open("POST", "http://localhost:3000/index.php", true);
        xhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");
        await xhttp.send("data="+ encrypt);
    })();
</script>
</body>
</html>
